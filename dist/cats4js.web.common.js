module.exports=function(r){var e={};function t(n){if(e[n])return e[n].exports;var o=e[n]={i:n,l:!1,exports:{}};return r[n].call(o.exports,o,o.exports,t),o.l=!0,o.exports}return t.m=r,t.c=e,t.d=function(r,e,n){t.o(r,e)||Object.defineProperty(r,e,{enumerable:!0,get:n})},t.r=function(r){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(r,"__esModule",{value:!0})},t.t=function(r,e){if(1&e&&(r=t(r)),8&e)return r;if(4&e&&"object"==typeof r&&r&&r.__esModule)return r;var n=Object.create(null);if(t.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:r}),2&e&&"string"!=typeof r)for(var o in r)t.d(n,o,function(e){return r[e]}.bind(null,o));return n},t.n=function(r){var e=r&&r.__esModule?function(){return r.default}:function(){return r};return t.d(e,"a",e),e},t.o=function(r,e){return Object.prototype.hasOwnProperty.call(r,e)},t.p="",t(t.s=0)}([function(r,e,t){"use strict";t.r(e),t.d(e,"parseConfig",(function(){return u}));const n=["string","number","object","boolean","function"],o={};var i=class{constructor(r){this.shorthandParser=r.shorthandParser}checkType(r,e,t,o){if(!r||!(null!==t))return;const i=typeof e;if(-1===n.indexOf(i))throw new TypeError("ConfigParser error: config property value has an unknown type: "+i);if(i!==t)throw new TypeError("ConfigParser error: property '"+o+"' must be of type '"+t+"' but is of type '"+i+"'.")}checkRequiredValue(r,e,t){if(!e&&r.required)throw new Error("ConfigParser error: config property '"+t+"' is required but not provided.")}getSchemaType(r){const e=r.type;if(null===e)return e;if(void 0===e)throw new Error("ConfigParser error: type property on schema is missing");if(-1===n.indexOf(e))throw new TypeError("ConfigParser error: schema property value has an unknown type: "+e);return e}handleRecursiveProperty(r,e,t,n){return!(!("object"==typeof t||void 0===t)||t instanceof Array||"type"in e)&&(n[r]={},this.walkConfig(t||{},e,n[r]),!0)}handleMissingSchema(r,e){const t=[];for(const n in r)n in e||t.push(n);if(t.length>0)throw new Error("ConfigParser error: The following config property was / properties were provided for which no schema exists: "+t.toString())}walkConfig(r,e,t){for(const n in e){const o=e[n],i="string"!=typeof o?o:this.shorthandParser.parse(o),s=r[n];if(this.handleRecursiveProperty(n,i,s,t))continue;const a=this.getSchemaType(i),u=n in r;this.checkRequiredValue(i,u,n),this.checkType(u,s,a,n),this.checkType(void 0!==i.default,i.default,a,"default value"),t[n]=u?s:i.default}this.handleMissingSchema(r,e)}parse(r,e,t={}){this.walkConfig(t,o);const n={};return this.walkConfig(r,e,n),n}};const s=["string","number","object","boolean"];var a=class{constructor(){}typeCheckNumber(r){return"number"==typeof r&&!1===isNaN(r)}parseNumberFromString(r){const e=1*r;if(r!==""+e)throw new TypeError("#todo | ConfigParserShorthand.parseNumberFromString input != output");if(!this.typeCheckNumber(e))throw new Error("#todo | ConfigParserShorthand.parseNumberFromString output not a number; isNaN?: "+isNaN(e));return e}parseBooleanFromString(r){return"true"===r||"false"!==r&&void 0}parseObjectFromString(r){if("[]"===r)return[];if("{}"===r)return{};throw new Error("Error in ConfigParserShorthand: failed to parse shorthand object. Only '[]' or '{}' are allowed as shorthand object properties.")}parseDefaultValue(r,e){let t=e;if(void 0!==e)return"string"===r||("number"===r?t=this.parseNumberFromString(t):"boolean"===r?t=this.parseBooleanFromString(t):"object"===r&&(t=this.parseObjectFromString(t))),t}parse(r){const e={type:null,default:void 0,required:!1},t=r.length;let n=r;if("*"===r[t-1]&&(e.required=!0,n=r.substring(0,t-1)),n=n.split(":"),e.type=n[0],-1===s.indexOf(e.type))throw new Error("shorthand: illegal type");return e.default=this.parseDefaultValue(e.type,n[1]),e}};function u(r={},e={}){const t=new a;return new i({shorthandParser:t}).parse(r,e)}}]);