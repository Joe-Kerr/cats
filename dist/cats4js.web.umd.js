!function(e,r){"object"==typeof exports&&"object"==typeof module?module.exports=r():"function"==typeof define&&define.amd?define([],r):"object"==typeof exports?exports.cats4js=r():e.cats4js=r()}(window,(function(){return function(e){var r={};function t(n){if(r[n])return r[n].exports;var o=r[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,t),o.l=!0,o.exports}return t.m=e,t.c=r,t.d=function(e,r,n){t.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:n})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,r){if(1&r&&(e=t(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(t.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var o in e)t.d(n,o,function(r){return e[r]}.bind(null,o));return n},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},t.p="",t(t.s=0)}([function(e,r,t){"use strict";t.r(r),t.d(r,"parseConfig",(function(){return u}));const n=["string","number","object","boolean","function"],o={};var i=class{constructor(e){this.shorthandParser=e.shorthandParser}checkType(e,r,t,o){if(!e||!(null!==t))return;const i=typeof r;if(-1===n.indexOf(i))throw new TypeError("ConfigParser error: config property value has an unknown type: "+i);if(i!==t)throw new TypeError("ConfigParser error: property '"+o+"' must be of type '"+t+"' but is of type '"+i+"'.")}checkRequiredValue(e,r,t){if(!r&&e.required)throw new Error("ConfigParser error: config property '"+t+"' is required but not provided.")}getSchemaType(e){const r=e.type;if(null===r)return r;if(void 0===r)throw new Error("ConfigParser error: type property on schema is missing");if(-1===n.indexOf(r))throw new TypeError("ConfigParser error: schema property value has an unknown type: "+r);return r}handleRecursiveProperty(e,r,t,n){return!(!("object"==typeof t||void 0===t)||t instanceof Array||"type"in r)&&(n[e]={},this.walkConfig(t||{},r,n[e]),!0)}handleMissingSchema(e,r){const t=[];for(const n in e)n in r||t.push(n);if(t.length>0)throw new Error("ConfigParser error: The following config property was / properties were provided for which no schema exists: "+t.toString())}walkConfig(e,r,t){for(const n in r){const o=r[n],i="string"!=typeof o?o:this.shorthandParser.parse(o),s=e[n];if(this.handleRecursiveProperty(n,i,s,t))continue;const a=this.getSchemaType(i),u=n in e;this.checkRequiredValue(i,u,n),this.checkType(u,s,a,n),this.checkType(void 0!==i.default,i.default,a,"default value"),t[n]=u?s:i.default}this.handleMissingSchema(e,r)}parse(e,r,t={}){this.walkConfig(t,o);const n={};return this.walkConfig(e,r,n),n}};const s=["string","number","object","boolean"];var a=class{constructor(){}typeCheckNumber(e){return"number"==typeof e&&!1===isNaN(e)}parseNumberFromString(e){const r=1*e;if(e!==""+r)throw new TypeError("#todo | ConfigParserShorthand.parseNumberFromString input != output");if(!this.typeCheckNumber(r))throw new Error("#todo | ConfigParserShorthand.parseNumberFromString output not a number; isNaN?: "+isNaN(r));return r}parseBooleanFromString(e){return"true"===e||"false"!==e&&void 0}parseObjectFromString(e){if("[]"===e)return[];if("{}"===e)return{};throw new Error("Error in ConfigParserShorthand: failed to parse shorthand object. Only '[]' or '{}' are allowed as shorthand object properties.")}parseDefaultValue(e,r){let t=r;if(void 0!==r)return"string"===e||("number"===e?t=this.parseNumberFromString(t):"boolean"===e?t=this.parseBooleanFromString(t):"object"===e&&(t=this.parseObjectFromString(t))),t}separateTypeAndDefault(e){const r=e.indexOf(":");return-1===r?[e,void 0]:[e.substring(0,r),e.substring(r+1,e.length)]}parse(e){const r={type:null,default:void 0,required:!1},t=e.length;let n=e;if("*"===e[t-1]&&(r.required=!0,n=e.substring(0,t-1)),n=this.separateTypeAndDefault(n),r.type=n[0],-1===s.indexOf(r.type))throw new Error("shorthand: illegal type");return r.default=this.parseDefaultValue(r.type,n[1]),r}};function u(e={},r={}){const t=new a;return new i({shorthandParser:t}).parse(e,r)}}])}));